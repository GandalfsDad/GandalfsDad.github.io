---
layout: post
title:  Guidance
date:   2023-06-06 17:00:00 +1000
categories: llm gpt 
---

[Guidance][GuidanceRepo] is a language/framework released by Microsoft with the goal of establishing a common interface for all
LLM models. I recently started exploring it with the intention of integrating it into my NotKevin library. I have set up a toy
project [battle simulator][AnyBattleRepo] for this purpose. The concept is that a user can input a character description and,
through some creative prompting, participate in a turn-based battle. I haven't completed this project yet, but below, I will discuss some of the objectives I have pursued thus far.

### Character Profile
The first step was to create an RPG-style profile for the characters. The Guidance repository had an example that was quite easy
to follow. As someone more comfortable with OpenAI's LLMs, I decided to use those models (set at a global level). Interestingly
enough, OpenAI doesn't support the pattern matching feature of Guidance. This isn't too much of an issue as it appears the
models above ada can all achieve a reasonable profile. By running the code below, the model makes several calls to the OpenAI 
API, and from the variables method I can extract the named parameter values.

{% highlight python %}
{% raw %}
def genCharacter(description):
    genChar = guidance("""The following is a character profile for an RPG game in JSON format.
    The range of values for health is 0-100.
    The range of values for attack, defense, spattack, and spdefense is 0-25 .
    ```json
    {
        "description": "{{description}}",
        "name": "{{gen 'name'}}",
        "attack": {{gen 'attack' stop=','}},
        "defense": {{gen 'defense'  stop=','}},
        "health": {{gen 'health'  stop=','}},
        "spattack": {{gen 'spattack'  stop=','}},
        "spdefense": {{gen 'spdefense'  stop='\\n'}},
        "items": [{{#geneach 'items' num_iterations=3}}
            "{{gen 'this'}}",{{/geneach}}
        ]
    }```""")

    result = genChar(description=description)
    return {k:V for k,V in result.variables().items() if k != 'llm'}
{% endraw %}
{% endhighlight %}

### A Nemesis
The next step was to create a nemesis. I believe this character should be generated by the model, rather than by the user. My
expectation is that if the model generates the nemesis, it would be more likely to align with a traditional RPG narrative and
possibly produce a nemesis that is a little more intriguing. From my trials, it appears my guess was mostly accurate. Even
though I prompt the model to generate an equally powerful nemesis, it tends to produce a more powerful description, which I 
find quite interesting.

{% highlight python %}
{% raw %}
def genNemesis(description):
    genNem = guidance("""The following is a description of an RPG character:
    {{description}}
    Here is a description of an equally powerful nemesis:
    {{gen 'nemesis'}}
    """)

    result = genNem(description=description)
    return result['nemesis']
{% endraw %}
{% endhighlight %}

The code for generating the nemesis is pretty straightforward. The nice thing about it is it creates a description that I can
feed directly into the `genCharacter` method without making any modifications.

### Scene of the Battle
At this point, we have two characters. The next logical step I could think of was to create a scenario to make the battle feel
more real. This is where I realized that the model could generate pretty rogue descriptions, so I decided to include a
`temperature` and `max_tokens` parameter to keep the descriptions more generic and consistent. I had tried to generate a scene
and starting positions for the characters separately, but the simpler models seemed to struggle with this and started describing
a battle instead. I opted for simplicity to try and reduce the relative cost.

{% highlight python %}
{% raw %}
def genBattleScene(character, nemesis):
    genScene = guidance("""The following is a description of two characters:
    {{character}}
    {{nemesis}}
    
    The following is a simple description of the location of the battle.
    {{gen 'scene' max_tokens=250 temperature=0}}
    """)
    result = genScene(character=character, nemesis=nemesis)
    return result['scene']
{% endraw %}
{% endhighlight %}

### The first move
From here, we venture into territory where I am still fine-tuning. My idea was to feed the model the character profiles and the
move description, and receive a damage output. From some experimentation, keeping it in JSON style brackets seemed to yield
numeric values often. While writing out this blog, I've realized it would make more sense to provide the character stats (I was
providing the description) and to include the scene.

{% highlight python %}
{% raw %}
def genMoveResults(move, character, nemesis):
    
    genImpact = guidance("""The following is a description of two characters in an RPG game:
    CharacterA:
    {{character}}
    CharacterB:
    {{nemesis}}

    The following is a move made by CharacterA:
    {{move}}

    This results in the following damage to characterB:
    ```{
          'damage':{{gen 'impact' stop=',' temperature=0.0 max_tokens=10}} 
        }```
    """)

    result = genImpact(move=move, character=character, nemesis=nemesis)

    return result['impact']
{% endraw %}
{% endhighlight %}

### Nemesis Move
This is the last part I've implemented so far. Like with the character descriptions, I realized I could flip the characters
around and reuse the `genMoveResults` method to calculate the impact of the nemesis' move. There is definitely more work to be
done here, as the model is susceptible to generating multiple impacts and responses.

{% highlight python %}
{% raw %}

def genNemesisMove(move, character, nemesis):
    
    genMove = guidance("""The following is a description of two characters in an RPG game:
    CharacterA:
    {{nemesis}}
    CharacterB:
    {{character}}

    The following is a move made by CharacterB:
    {{move}}

    This caused the following impact on CharacterA:
    {{gen 'impact' temperature=0.0 max_tokens=100}}

    After this move CharecterA does the following:
    {{gen 'nemesis_move' temperature=0.0 max_tokens=100}}
    """)

    result = genMove(move=move, character=character, nemesis=nemesis)

    return f"{result['impact']}{result['nemesis_move']}"
{% endraw %}
{% endhighlight %}

### Lessons Learned and Next Steps
The primary thing I've learned from this is that trying to save money often results in less effective results. I've made
attempts to get the cheaper models to perform well, but it's clear that the more expensive models require less fine-tuning.
Another key takeaway is the importance of parameters in the generate function. The flexibility that the Guidance package
provides in its API calls is quite powerful.

My next steps in this project are to get the battle running in a loop, accurately track health, and provide a satisfying death
scene for the loser.

Here is an example of the initial stages of the battle with the current implementation. It's quite comical but hopefully gives
you an idea of what I'm aiming to achieve.

![ExampleBattle]({{ "/assets/images/Battle.png" | relative_url }})

[GuidanceRepo]: https://github.com/microsoft/guidance
[AnyBattleRepo]: https://github.com/GandalfsDad/anybattle